
import { Item } from './models/item';
import { AngularFirestore, AngularFirestoreDocument, AngularFirestoreCollection, DocumentChangeAction } from 'angularfire2/firestore';
import { Injectable } from '@angular/core';
import { ShoppingCart } from './models/shopping-cart';
import { Observable, combineLatest, of, from, EMPTY } from 'rxjs';
import { Product } from './models/product';
import { map, take, flatMap, filter, mergeMap, switchMap, withLatestFrom, distinct, debounceTime, reduce } from 'rxjs/operators';
import { regExpEscape } from '@ng-bootstrap/ng-bootstrap/util/util';
import { database } from 'firebase';


interface DocWithId { id: string; }

@Injectable({
  providedIn: 'root'
})
export class ShoppingCartService {

  constructor(private firestore: AngularFirestore) {
  }

  private create() {

    console.log("create cart called...");
    let id = this.firestore.createId();
    console.log("random id generated by firestore: " + id);
    let cart = { dateCreated: new Date().getTime() };
    let promise = this.firestore
      .collection('shopping-carts')
      .doc(id)
      .set(cart)
      .then(() => {
        let shoppingCart: ShoppingCart = { id: id, dateCreated: cart.dateCreated, items: [] };
        return shoppingCart;
      });
    return promise;
  }

  private async getOrCreateCartId() {
    let cartId = localStorage.getItem('cartId');

    if (cartId) return cartId;

    console.log("cardId not found form localStorage");
    let result = await this.create();
    localStorage.setItem("cartId", result.id);

    return result.id;
  }

  public getItem(cartId: string, productId: string) {
    return this.firestore
      .collection('shopping-carts')
      .doc(cartId)
      .collection('items')
      .doc(productId)
  }

  async getItems() {
    let cartId = await this.getOrCreateCartId();
    let itemList = []; 
    console.log("getItems called using cardId: "+cartId);
    let x = this.firestore.collection('shopping-carts')
      .doc(cartId).collection('items').snapshotChanges();
""
    x.subscribe(n =>{
      n.map(a => {
        let data = a.payload.doc.data()
        let id = a.payload.doc.id;
        let item = {id, ...data};
        return item;
      }).map(i => {
        itemList.push(i)
      })
    })
    return from(itemList);
  }


  convertSnapshots<T>(snaps) {
    return <T[]>snaps.map(snap => {
      let retValue = {
        id: snap.payload.doc.id,
        ...snap.payload.doc.data()
      };
      return retValue;
    });
  }

  async getShoppingCart<T extends DocWithId>() {
 
    let cartId = await this.getOrCreateCartId();

    let cartList = this.firestore
      .collection('shopping-carts')
      .snapshotChanges()
      .pipe(
        map(this.convertSnapshots),
        map((documents: T[]) =>
          documents.map(document => {
  
            return this.firestore
              .collection(`shopping-carts/${document.id}/items`)
              .snapshotChanges()
              .pipe(
                map(this.convertSnapshots),
                map(subdocuments =>
                  Object.assign(document, { ["items"]: subdocuments })
                )
              );      
          })
        ),
        flatMap(combined => combineLatest(combined)),
      );

      //extract only the shopping card with specific cartId
      return cartList.pipe(
        map(items => items.filter(item => item.id == cartId)), 
        flatMap(items => items)
      );
  }


  async addToCart(product: Product) {
    console.log("addToCart called");

    let cartId = await this.getOrCreateCartId();
    console.log("cartId is: " + cartId + ", productId is: " + product.id);
    let document = this.getItem(cartId, product.id);

    document.snapshotChanges()
      .pipe(take(1))
      .subscribe(action => {
        if (action.payload.exists) {
          let i = action.payload.data() as Item;
          let quantity = i.quantity + 1
          document.update({ quantity: quantity });
        } else {
          document.set({ quantity: 1, product: product });
          console.log("new product added to shopping-cart");
        }
      });

  }

  async removeFromCart(product: Product) {
    console.log("removeFromCart called...");
    let cartId = await this.getOrCreateCartId();
    console.log("cartId is: " + cartId + ", productId is: " + product.id);
    let document = this.getItem(cartId, product.id);

    document.snapshotChanges()
      .pipe(take(1))
      .subscribe(action => {
        if (action.payload.exists) {
          let i = action.payload.data() as Item;
          let quantity = i.quantity - 1
          document.update({ quantity: quantity });
          console.log("quantity: ", quantity);
        }
      });
  }

  private getCart(cartId: string) {
    console.log("getCart called...");
    let promise = this.firestore.collection('shopping-carts').doc(cartId).get().toPromise()
      .then((snapshot) => {
        return snapshot.data() as ShoppingCart;
      });
    return promise;
  }
}